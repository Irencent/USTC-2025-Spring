age <- ifelse(
format(date_dis_pos, "%m-%d") >= format(date_bir, "%m-%d"),
as.numeric(format(date_dis_pos, "%Y")) - as.numeric(format(date_bir, "%Y")),
as.numeric(format(date_dis_pos, "%Y")) - as.numeric(format(date_bir, "%Y")) - 1
)
age
sink("test.txt")
cat("发病年龄:", age, "周岁\n")
sink()
date_dis_monyy <- format(date_dis_pos, "%b%y")
date_dis_monyy
recheck_dates <- seq(
from = as.Date(date_dis_pos),
by = "7 days",
length.out = 10
)
recheck_dates <- seq(
from = as.Date(date_dis_pos),
by = "7 days",
length.out = 10
)
recheck_dates
date_bir <- "1961/3/1"
date_dis <- "2022年1月1日"
date_dis <- gsub("[年月日]", "-", date_dis)
date_bir <- as.Date(date_bir)
date_dis <- as.POSIXct(date_dis)
date_bir
date_dis
format(date_bir, "%Y")
format(date_bir, "%m")
age <- ifelse(
format(date_dis_pos, "%m-%d") >= format(date_bir, "%m-%d"),
as.numeric(format(date_dis, "%Y")) - as.numeric(format(date_bir, "%Y")),
as.numeric(format(date_dis, "%Y")) - as.numeric(format(date_bir, "%Y")) - 1
)
age
sink("test.txt")
cat("发病年龄:", age, "周岁\n")
sink()
date_dis_monyy <- format(date_dis, "%b%y")
date_dis_monyy
recheck_dates <- seq(
from = as.Date(date_dis),
by = "7 days",
length.out = 10
)
recheck_dates
age <- ifelse(
format(date_dis, "%m-%d") >= format(date_bir, "%m-%d"),
as.numeric(format(date_dis, "%Y")) - as.numeric(format(date_bir, "%Y")),
as.numeric(format(date_dis, "%Y")) - as.numeric(format(date_bir, "%Y")) - 1
)
age
sink("test.txt")
cat("发病年龄:", age, "周岁\n")
sink()
knitr::opts_chunk$set(echo = TRUE)
x <- factor(c("男", "女", "男", "女"))
levels(x)[levels(x) == "男"] <- "M"
levels(x)[levels(x) == "女"] <- "F"
cat(as.character(x), file = "factor.txt")
# 创建有序因子
y <- factor(c("大一", "大四", "大三", "大二"),
levels = c("大一", "大二", "大三", "大四"),
ordered = TRUE)
# 排序并输出
sorted_y <- sort(y)
print(sorted_y)
x <- c(100, 65, 80, 79, 88, 95, 93, 35, 56, 68)
# 从小到大排序
sorted_x <- sort(x)
cat("排序后的向量:", sorted_x, "\n")
# 最大值
max_value <- max(x)
cat("最大值:", max_value, "\n")
# 最小值
min_value <- min(x)
cat("最小值:", min_value, "\n")
# 中位数
median_value <- median(x)
cat("中位数:", median_value, "\n")
# 第三大的元素（先降序排序后取第三个）
third_largest <- sort(x, decreasing = TRUE)[3]
cat("第三大的元素:", third_largest, "\n")
odd_position_elements <- x[seq(1, length(x), by = 2)]
cat("奇数位置的元素:", odd_position_elements, "\n")
even_values <- x[x %% 2 == 0]
cat("偶数元素:", even_values, "\n")
m <- diag(1:10, nrow = 10, ncol = 10)
print("初始矩阵 m:")
print(m)
x <- rep(1, 10)  # 创建长度为10的全1向量
inv_m <- solve(m)  # 计算逆矩阵
y <- inv_m %*% x  # 解方程 m𝑦=𝑥
print("解向量 y:")
print(y)
m[2, -2] <- 100  # -2 表示排除第2列（对角线）
print("修改后的矩阵 m:")
print(m)
element <- m[5, 9]
cat("提取的元素值:", element, "\n")
m[5, 9] <- NA  # 赋值为NA
print("修改后的矩阵 m:")
print(m)
colnames(m) <- paste0("c", 1:10)
print("添加列名后的矩阵 m:")
print(m)
m <- rbind(m, x)  # 添加第11行
print("添加新行后的矩阵 m:")
print(m)
row_means <- rowMeans(m, na.rm = TRUE)
print("按行计算的平均值:")
print(row_means)
arr <- array(
data = c(m, 2*m, 3*m),  # 依次填充 m, 2m, 3m
dim = c(10, 10, 3)       # 维度为10×10×3
)
print("三维数组 arr 的维度:")
print(dim(arr))
age <- score.age
score <- list(name="李明", id = "PB1", age=19, scores=c(85, 76, 90))
age <- score.age
score <- list(name="李明", id = "PB1", age=19, scores=c(85, 76, 90))
current_year <- as.integer(format(Sys.Date(), "%Y"))
birth_year <- current_year - score$age
cat("出生年份:", birth_year, "\n")
y <- score$scores
mean_score <- mean(y)
cat("平均成绩:", mean_score, "\n")
score$excellent <- mean_score > 85
print(score)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- subset(pat1, !is.na(性别))  # 或使用 pat1 <- pat1[complete.cases(pat1$性别), ]
# 查看处理后的数据
head(pat1)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- pat1[complete.cases(pat1$性别), ]
# 查看处理后的数据
head(pat1)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- pat1[complete.cases(pat1$性别), ]
# 查看处理后的数据
head(pat1)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- pat1[complete.cases(pat1$性别), ]
# 查看处理后的数据
pat1
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- pat1[pat1$年龄 != '' ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- pat1[pat1$性别 != '' ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除性别缺失的行
pat1 <- pat1[!is.na(pat1$性别), ]
# 查看处理后的数据
pat1
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
# 查看处理后的数据
pat1
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
install.packages(dplyr)
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
install.packages('dplyr')
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
stats <- pat1 %>%
group_by(分型) %>%
summarise(
平均住院时间 = round(mean(住院时间, na.rm = TRUE), 1),
最长住院时间 = max(住院时间, na.rm = TRUE),
最短住院时间 = min(住院时间, na.rm = TRUE)
)
print(stats)
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
stats <- pat1 %>%
group_by(分型) %>%
summarise(
平均住院时间 = round(mean(住院时间, na.rm = TRUE), 1),
最长住院时间 = max(住院时间, na.rm = TRUE),
最短住院时间 = min(住院时间, na.rm = TRUE)
)
print(stats)
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
pat1
# 按分型计算统计量
library(dplyr)
stats <- pat1 %>%
group_by(分型) %>%
summarise(
平均住院时间 = round(mean(住院时间, na.rm = TRUE), 1),
最长住院时间 = max(住院时间, na.rm = TRUE),
最短住院时间 = min(住院时间, na.rm = TRUE)
)
print(stats)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- "20200205"
# 查看处理后的数据
pat1
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- 20200205
# 查看处理后的数据
pat1
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
stats <- pat1 %>%
group_by(分型) %>%
summarise(
平均住院时间 = round(mean(住院时间, na.rm = TRUE), 1),
最长住院时间 = max(住院时间, na.rm = TRUE),
最短住院时间 = min(住院时间, na.rm = TRUE)
)
print(stats)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- 20200205
# 查看处理后的数据
pat1
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
stats <- pat1 %>%
group_by(分型) %>%
summarise(
平均住院时间 = round(mean(住院时间, na.rm = TRUE), 1),
最长住院时间 = max(住院时间, na.rm = TRUE),
最短住院时间 = min(住院时间, na.rm = TRUE)
)
print(stats)
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- as.Date("20200205", format = "%Y%m%d")
# 查看处理后的数据
pat1
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- as.Date("20200205", format = "%Y%m%d")
# 查看处理后的数据
pat1
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- as.Date("20200205", format = "%Y%m%d")
# 查看处理后的数据
pat1[51, ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[51, "入院时间"] <- as.Date("20200205", format = "%Y%m%d")
# 查看处理后的数据
pat1[50, ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[50, "入院时间"] <- as.Date("20200205", format = "%Y%m%d")
# 查看处理后的数据
pat1[50, ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[50, "入院时间"] <- as.Date("20200205", format = "%Y%m%d")
# 查看处理后的数据
pat1[50, ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[50, "入院时间"] <- 20200205
# 查看处理后的数据
pat1[50, ]
# 读取数据
pat1 <- read.csv("covid19.csv")
# 删除空字符串和NA值
pat1 <- pat1[!(is.na(pat1$性别) | pat1$性别 == ""), ]
pat1[50, "入院时间"] <- 20200205
# 查看处理后的数据
pat1
# 计算住院时间（假设日期列为字符类型，需先转换为日期）
pat1$入院时间 <- as.Date(pat1$入院时间)
pat1$出院时间 <- as.Date(pat1$出院时间)
pat1$住院时间 <- as.numeric(pat1$出院时间 - pat1$入院时间) + 1
# 按分型计算统计量
library(dplyr)
stats <- pat1 %>%
group_by(分型) %>%
summarise(
平均住院时间 = round(mean(住院时间, na.rm = TRUE), 1),
最长住院时间 = max(住院时间, na.rm = TRUE),
最短住院时间 = min(住院时间, na.rm = TRUE)
)
print(stats)
# 将年龄分段
pat1$年龄段 <- cut(
pat1$年龄,
breaks = c(0, 18, 45, 60, 70, Inf),
labels = c("0-18", "19-45", "46-60", "61-70", "70以上"),
right = FALSE  # 左闭右开区间，例如 [0,18)
)
# 查看新增的年龄段列
table(pat1$年龄段)
# 计算发病人数和百分比
cross_tab <- pat1 %>%
group_by(年龄段, 性别) %>%
summarise(人数 = n(), .groups = "drop") %>%
mutate(百分比 = round(人数 / sum(人数) * 100, 1))
# 转换为宽格式（每行一个年龄段）
library(tidyr)
install.packages('tidyr')
# 计算发病人数和百分比
cross_tab <- pat1 %>%
group_by(年龄段, 性别) %>%
summarise(人数 = n(), .groups = "drop") %>%
mutate(百分比 = round(人数 / sum(人数) * 100, 1))
# 转换为宽格式（每行一个年龄段）
library(tidyr)
cross_tab_wide <- cross_tab %>%
pivot_wider(
names_from = 性别,
values_from = c(人数, 百分比),
names_glue = "{性别}_{.value}"
)
# 保存为CSV
write.csv(cross_tab_wide, "年龄性别分布.csv", row.names = FALSE)
# 计算发病人数和百分比
cross_tab <- pat1 %>%
group_by(年龄段, 性别) %>%
summarise(人数 = n(), .groups = "drop") %>%
mutate(百分比 = round(人数 / sum(人数) * 100, 1))
# 转换为宽格式（每行一个年龄段）
library(tidyr)
cross_tab_wide <- cross_tab %>%
pivot_wider(
names_from = 性别,
values_from = c(人数, 百分比),
names_glue = "{性别}_{.value}"
)
# 保存为CSV
write.csv(cross_tab_wide, "年龄性别分布.csv", row.names = FALSE)
# 读取数据
pat2 <- read.csv("covid19-3.csv")
# 输出列名和前3行
cat("列名:", colnames(pat2), "\n")
cat("前三行内容:\n")
print(head(pat2, 3))
# 假设合并依据为患者ID（假设列名为"患者ID"）
pat <- left_join(pat1, pat2, by = "患者ID")
# 假设合并依据为患者ID（假设列名为"患者ID"）
pat <- left_join(pat1, pat2, by = "序号")
# 查看合并后的数据
dim(pat)
# 假设合并依据为患者ID（假设列名为"患者ID"）
pat <- left_join(pat1, pat2, by = "序号")
# 查看合并后的数据
pat
# 找出病人最多的三个职业
top_occupations <- pat %>%
count(职业, sort = TRUE) %>%
top_n(3)
cat("病人最多的三个职业:\n")
print(top_occupations)
# 统计每个职业的住院时间和年龄
occupation_stats <- pat %>%
filter(职业 %in% top_occupations$职业) %>%
group_by(职业) %>%
summarise(
住院时间_不超过10天 = sum(住院时间 <= 10, na.rm = TRUE),
住院时间_超过10天 = sum(住院时间 > 10, na.rm = TRUE),
平均年龄 = round(mean(年龄, na.rm = TRUE), 1)
)
print(occupation_stats)
knitr::opts_chunk$set(echo = TRUE)
# 定义分段函数
myfun <- function(x, lambda) {
ifelse(x > lambda, x - lambda,
ifelse(x < -lambda, x + lambda, 0))
}
# 生成数据范围
x <- seq(-3, 3, length.out = 1000)
lambda <- 1  # 可调整 lambda 的值
# 计算不同 lambda 对应的函数值
y_lambda <- myfun(x, lambda)
y_lambda0 <- myfun(x, 0)
# 绘制图像
plot(x, y_lambda, type = "l", col = "blue", lwd = 2,
xlab = "x", ylab = "f(x)",
main = expression(paste("Function f(x) with ", lambda, "=1 and ", lambda, "=0")))
lines(x, y_lambda0, col = "red", lty = 2, lwd = 2)
legend("topleft", legend = c(expression(lambda == 1), expression(lambda == 0)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
knitr::opts_chunk$set(echo = TRUE)
coordinate_descent <- function(X, y, lambda, max_iter = 1000, tol = 1e-6) {
p <- ncol(X)
beta <- rep(0, p)  # 初始化 beta 为全零
iter <- 0
converged <- FALSE
while (iter < max_iter && !converged) {
beta_old <- beta
# 遍历每个维度更新系数
for (j in 1:p) {
X_j <- X[, j]
# 计算残差（移除当前维度的贡献）
r <- y - X %*% beta + X_j * beta[j]
# 计算局部最优解
a <- sum(X_j * r) / sum(X_j^2)
lambda_scaled <- lambda / sum(X_j^2)
beta[j] <- myfun(a, lambda_scaled)
}
# 检查收敛条件
if (sqrt(sum((beta - beta_old)^2)) < tol) converged <- TRUE
iter <- iter + 1
}
beta
}
set.seed(123)
beta_true <- c(1, 0, 0.5)
n <- 100
library(MASS)
# 生成协方差矩阵
Sigma <- matrix(0.5, nrow = 3, ncol = 3)
diag(Sigma) <- 1
# 生成数据
X <- mvrnorm(n, mu = c(0, 0, 0), Sigma = Sigma)
y <- X %*% beta_true + rnorm(n, 0, 0.5)
# 运行算法（lambda=0 时应接近 OLS 解）
beta_hat <- coordinate_descent(X, y, lambda = 0.1)
print(beta_hat)  # 预期输出接近 [1.0, 0.0, 0.5]
library(ggplot2)
install.packages('ggplot2')
install.packages('ggplot')
install.packages('ggplot2')
library(ggplot2)
# 生成 lambda 序列
lambda_seq <- exp(seq(log(0.01), log(10), length.out = 50))
# 计算不同 lambda 下的系数估计
beta_path <- t(sapply(lambda_seq, function(lam) coordinate_descent(X, y, lam)))
# 转换为长格式数据
library(tidyr)
df <- data.frame(lambda = lambda_seq, beta1 = beta_path[,1],
beta2 = beta_path[,2], beta3 = beta_path[,3])
df_long <- pivot_longer(df, cols = -lambda, names_to = "coefficient")
# 绘制路径图
ggplot(df_long, aes(x = lambda, y = value, color = coefficient)) +
geom_line(linewidth = 1) +
scale_x_log10() +  # x轴取对数刻度
labs(x = "lambda (log scale)", y = "Coefficient Estimate",
title = "Lasso Solution Path") +
theme_minimal()
shiny::runApp('Desktop/实用统计软件/EXP4/Buffon_experiment')
runApp('Desktop/实用统计软件/EXP4/Buffon_experiment')
