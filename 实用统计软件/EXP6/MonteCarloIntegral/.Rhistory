devtools::document()
devtools::check()
devtools::build()
library(MonteCarloIntegral)
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
set.seed(15)
result <- mc_int(
x_range = c(-2, 2),
fun = "(1/sqrt(2*pi)) * exp(-x^2/2)",
B = 1e6,
seed = 15
)
# 输出结果
cat("Estimated Integral:", result$I, "\n")
cat("True Value (approx):", pnorm(2) - pnorm(-2), "\n")
# 绘图
plot(result)
plot(obj)
# 绘图
plot(result)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
devtools::load_all()
devtools::load_all()
obj <- mc_int(c(0, 1), "x^2*sin(x^2/pi)", 1e3)
plot(obj)
methods("plot")
export(mc_int)
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all()
obj <- mc_int(c(0, 1), "x^2*sin(x^2/pi)", 1e3)
plot(obj)
knitr::opts_chunk$set(echo = TRUE)
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
# 计算积分
set.seed(15)
result <- mc_int(
x_range = c(-2, 2),
fun = "exp(-x^2/2)/sqrt(2*pi)",  # 正确语法
B = 1e6,
seed = 15
)
# 输出结果
cat("Estimated Integral:", result$I, "\n")           # 应接近 0.9544997
cat("True Value (approx):", pnorm(2) - pnorm(-2), "\n")
# 绘图
plot(result)  # 应显示正态分布曲线和积分区域
library(Rcpp)
# 编译Rcpp函数
sourceCpp("alternating_sum.cpp")
# 生成数据
set.seed(15)
x <- rnorm(1e6)  # 生成1e6个标准正态分布样本
# 计算交错和
result <- alternating_sum(x)
# 输出结果
cat("交错和 S =", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("convolve.cpp")
# 输入向量
x <- c(1, 2, 3, 4, 5)
y <- c(1, 2, 3)
# 计算离散卷积
result <- convolve_cpp(x, y)
# 输出结果
cat("离散卷积结果：", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("max_row_norm.cpp")
# 输入矩阵
mat <- matrix(c(1, 2, 4, 9), nrow = 2, byrow = TRUE)
print("矩阵:")
print(mat)
# 计算各行模的最大值
result <- max_row_norm(mat)
# 输出结果
cat("\n各行模的最大值:", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("create_dataframe.cpp")
# 生成数据框
df <- create_df()
# 输出结果
print(df)
library(Rcpp)
# 编译Rcpp函数
sourceCpp("f_xy.cpp")
# 生成数据
set.seed(15)
x <- runif(10, min = 4, max = 6)
y <- runif(10, min = 4, max = 6)
# 计算函数值
result <- f_xy(x, y)
# 输出结果
cat("x:", round(x, 4), "\n")
cat("y:", round(y, 4), "\n")
cat("f(x, y):", round(result, 4), "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("monte_carlo_integral.cpp")
# 计算积分
set.seed(15)  # 额外设置种子（可选，函数内部已设置）
result <- monte_carlo_integral(a = -2, b = 2, B = 1e6, seed = 15)
# 输出结果
cat("蒙特卡洛估计值:", result, "\n")
cat("理论值 (pnorm(2) - pnorm(-2)):", pnorm(2) - pnorm(-2), "\n")
devtools::document()
devtools::document()
devtools::document()
knitr::opts_chunk$set(echo = TRUE)
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
# 计算积分
set.seed(15)
result <- mc_int(
x_range = c(-2, 2),
fun = "exp(-x^2/2)/sqrt(2*pi)",  # 正确语法
B = 1e6,
seed = 15
)
# 输出结果
cat("Estimated Integral:", result$I, "\n")           # 应接近 0.9544997
cat("True Value (approx):", pnorm(2) - pnorm(-2), "\n")
# 绘图
plot(result)  # 应显示正态分布曲线和积分区域
library(Rcpp)
# 编译Rcpp函数
sourceCpp("alternating_sum.cpp")
# 生成数据
set.seed(15)
x <- rnorm(1e6)  # 生成1e6个标准正态分布样本
# 计算交错和
result <- alternating_sum(x)
# 输出结果
cat("交错和 S =", result, "\n")
knitr::opts_chunk$set(echo = TRUE)
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
# 计算积分
set.seed(15)
result <- mc_int(
x_range = c(-2, 2),
fun = "exp(-x^2/2)/sqrt(2*pi)",  # 正确语法
B = 1e6,
seed = 15
)
# 输出结果
cat("Estimated Integral:", result$I, "\n")           # 应接近 0.9544997
cat("True Value (approx):", pnorm(2) - pnorm(-2), "\n")
# 绘图
plot(result)  # 应显示正态分布曲线和积分区域
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
# 计算积分
set.seed(15)
result <- mc_int(
x_range = c(-2, 2),
fun = "exp(-x^2/2)/sqrt(2*pi)",  # 正确语法
B = 1e6,
seed = 15
)
# 输出结果
cat("Estimated Integral:", result$I, "\n")           # 应接近 0.9544997
cat("True Value (approx):", pnorm(2) - pnorm(-2), "\n")
# 绘图
plot(result)  # 应显示正态分布曲线和积分区域
library(Rcpp)
# 编译Rcpp函数
sourceCpp("alternating_sum.cpp")
# 生成数据
set.seed(15)
x <- rnorm(1e6)  # 生成1e6个标准正态分布样本
# 计算交错和
result <- alternating_sum(x)
# 输出结果
cat("交错和 S =", result, "\n")
#library(Rcpp)
# 编译Rcpp函数
sourceCpp("alternating_sum.cpp")
# 生成数据
set.seed(15)
x <- rnorm(1e6)  # 生成1e6个标准正态分布样本
# 计算交错和
result <- alternating_sum(x)
# 输出结果
cat("交错和 S =", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("convolve.cpp")
# 输入向量
x <- c(1, 2, 3, 4, 5)
y <- c(1, 2, 3)
# 计算离散卷积
result <- convolve_cpp(x, y)
# 输出结果
cat("离散卷积结果：", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("alternating_sum.cpp")
# 生成数据
set.seed(15)
x <- rnorm(1e6)  # 生成1e6个标准正态分布样本
# 计算交错和
result <- alternating_sum(x)
# 输出结果
cat("交错和 S =", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("max_row_norm.cpp")
# 输入矩阵
mat <- matrix(c(1, 2, 4, 9), nrow = 2, byrow = TRUE)
print("矩阵:")
print(mat)
# 计算各行模的最大值
result <- max_row_norm(mat)
# 输出结果
cat("\n各行模的最大值:", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("create_dataframe.cpp")
# 生成数据框
df <- create_df()
# 输出结果
print(df)
library(Rcpp)
# 编译Rcpp函数
sourceCpp("f_xy.cpp")
# 生成数据
set.seed(15)
x <- runif(10, min = 4, max = 6)
y <- runif(10, min = 4, max = 6)
# 计算函数值
result <- f_xy(x, y)
# 输出结果
cat("x:", round(x, 4), "\n")
cat("y:", round(y, 4), "\n")
cat("f(x, y):", round(result, 4), "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("monte_carlo_integral.cpp")
# 计算积分
set.seed(15)  # 额外设置种子（可选，函数内部已设置）
result <- monte_carlo_integral(a = -2, b = 2, B = 1e6, seed = 15)
# 输出结果
cat("蒙特卡洛估计值:", result, "\n")
cat("理论值 (pnorm(2) - pnorm(-2)):", pnorm(2) - pnorm(-2), "\n")
devtools::document()
devtools::build()
knitr::opts_chunk$set(echo = TRUE)
install.packages("./TimesTwoRcpp_0.1.0.tar.gz", repos = NULL)
install.packages('MonteCarloIntegral_1.0.0.tar.gz', repos = NULL)
library(MonteCarloIntegral)
# 示例测试
obj <- mc_int(x_range = c(0, 1), fun = "x^2*sin(x^2/pi)", B = 1e3, seed = 123)
plot(obj)
# 计算积分
set.seed(15)
result <- mc_int(
x_range = c(-2, 2),
fun = "exp(-x^2/2)/sqrt(2*pi)",  # 正确语法
B = 1e6,
seed = 15
)
# 输出结果
cat("Estimated Integral:", result$I, "\n")           # 应接近 0.9544997
cat("True Value (approx):", pnorm(2) - pnorm(-2), "\n")
# 绘图
plot(result)  # 应显示正态分布曲线和积分区域
library(Rcpp)
# 编译Rcpp函数
sourceCpp("alternating_sum.cpp")
# 生成数据
set.seed(15)
x <- rnorm(1e6)  # 生成1e6个标准正态分布样本
# 计算交错和
result <- alternating_sum(x)
# 输出结果
cat("交错和 S =", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("convolve.cpp")
# 输入向量
x <- c(1, 2, 3, 4, 5)
y <- c(1, 2, 3)
# 计算离散卷积
result <- convolve_cpp(x, y)
# 输出结果
cat("离散卷积结果：", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("max_row_norm.cpp")
# 输入矩阵
mat <- matrix(c(1, 2, 4, 9), nrow = 2, byrow = TRUE)
print("矩阵:")
print(mat)
# 计算各行模的最大值
result <- max_row_norm(mat)
# 输出结果
cat("\n各行模的最大值:", result, "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("create_dataframe.cpp")
# 生成数据框
df <- create_df()
# 输出结果
print(df)
library(Rcpp)
# 编译Rcpp函数
sourceCpp("f_xy.cpp")
# 生成数据
set.seed(15)
x <- runif(10, min = 4, max = 6)
y <- runif(10, min = 4, max = 6)
# 计算函数值
result <- f_xy(x, y)
# 输出结果
cat("x:", round(x, 4), "\n")
cat("y:", round(y, 4), "\n")
cat("f(x, y):", round(result, 4), "\n")
library(Rcpp)
# 编译Rcpp函数
sourceCpp("monte_carlo_integral.cpp")
# 计算积分
set.seed(15)  # 额外设置种子（可选，函数内部已设置）
result <- monte_carlo_integral(a = -2, b = 2, B = 1e6, seed = 15)
# 输出结果
cat("蒙特卡洛估计值:", result, "\n")
cat("理论值 (pnorm(2) - pnorm(-2)):", pnorm(2) - pnorm(-2), "\n")
library(timesTwo)
library(TimesTwo)
library(TimesTwoRcpp)
TimesTwo(c(1, 2, 3))
library(TimesTwoRcpp)
timesTwo(c(1, 2, 3))
