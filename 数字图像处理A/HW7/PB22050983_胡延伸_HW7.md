### 1. (1) 是否能用变长编码法压缩一幅已直方图均衡化的具有 \(2^n\) 级灰度的图像？ (2) 这样的图像中包含像素间冗余吗？

**(1)**
能使用变长编码法压缩，但压缩效率很低，可能无法实现有效压缩。
  
对于具有 \(2^n\) 级灰度的图像，利用直方图均衡化后，每个灰度级的概率理论上接近 \( \frac{1}{2^n} \)， 即近似均匀，每个灰度级的概率差异很小。此时，变长编码会退化为接近固定长度编码。理论上，平均码长接近 \(n\) 位/像素，压缩比约为 1:1（即无压缩）。

**(2)**

是的，这样的图像中仍然包含像素间冗余。

像素间冗余是指图像中像素值之间的相关性导致的冗余。直方图均衡化仅改变图像的灰度值分布（即调整单个像素的灰度，使直方图均匀化），但它不改变像素之间的空间关系或相关性，图像内容（如自然场景）的固有空间冗余（如自相似性或局部平滑性）并未被破坏。

---

### 2、 (1) 对一个具有3个符号的信源，有多少唯一的Huffman码？ (2)构造这些码。

**(1)**

- 当符号的概率相等时，存在 3个唯一的Huffman码;
- 当最小概率唯一且次小概率有并列时，有2种;
- 当最大概率唯一，且次大概率有并列时，有1种;
- 当所有概率互异时，有1种。

**(2)**

设信源符号为 A, B, C

1. $p(A) = p(B) = p(C)$
   Huffman 树有如下三种
   ```
        root
       /    \
      *      C
     / \
    A   B

        root
       /    \
      *      B
     / \
    A   C

        root
       /    \
      *      A
     / \
    B   C
    ```
    示例编码有三种: `A: 00, B: 01, C: 1`, `A: 00, B: 1, C: 01`, `A: 1, B: 00, C: 01`.

2. $p(A) > p(B) = p(C)$
   Huffman 树结构如下:
   ```
        root
       /    \
     A       *
            / \
           B   C
    ```
    示例编码为: `A: 0, B: 10, C: 11`.

3. $p(A) < p(B) = p(C)$
   Huffman 树有如下两种
   ```
        root
       /    \
      *      C
     / \
    A   B

        root
       /    \
      *      B
     / \
    A   C
    ```
    示例编码有两种: `A: 00, B: 01, C: 1`, `A: 00, B: 1, C: 01`

4. $p(A) < p(B) < p(C)$ (三种符号概率不同，不妨设 A 最小， C 最大)
   Huffman 树结构如下:
   ```
        root
       /    \
     A       *
            / \
           B   C
    ```
    示例编码为: `A: 0, B: 10, C: 11`.

---

###  3、 已知符号a,e,i,o,u,?的出现概率分别是0.2，0.3，0.1，0.2，0.1， 0.1，对0.23355进行解码，解码长度为6。

Huffman 树结构如下:

```
             *
           /   \
         *       *
       /   \    /   \
     o     *   e     *
          / \       / \
         i   u     ?   a

```


最终编码如下:

| 符号 | 编码  |
| -- | --- |
| o  | 00  |
| i  | 010 |
| u  | 011 |
| e  | 10  |
| ?  | 110 |
| a  | 111 |

---

将 0.23355 转为二进制小数, 前 14 位为：

```
0.23355 ≈ 0.00111011111001...
```

即二进制前缀：**0001110111110010...**



从 `0001110111110010...` 开始：

1. `00` → o
2. `011` → u
3. `10` → e
4. `111` → a
5. `110` → ?
6. `010` → i

所以：

**解码结果为：o u e a ? i**

---

